<?xml version="1.0" encoding="ISO-8859-1"?>
<!--  The tags attribute is a free test attribute which meaning is defined by the uHAL user -->
<node id="top">
  <node id="GEM_AMC">

    <!--TTC module -->
    <node id="TTC"  address="0x00300000"
          description="TTC control and monitoring. It takes care of locking to the TTC clock coming from the backplane as well as decoding TTC commands and forwarding that to all other modules in the design. It also provides several control and monitoring registers (resets, command decoding configuration, clock and data status, bc0 status, command counters and a small spy buffer)"
          fw_is_module="true"
          fw_module_file="../common/hdl/ttc/ttc.vhd"
          fw_user_clock_signal="clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="5"
          fw_reg_addr_lsb="0">
        <node id="CTRL" address="0x0" description="TTC control">
            <node id="MODULE_RESET" address="0x0" mask="0x80000000" permission="w" description="TTC module reset"
                  fw_signal="ttc_ctrl.reset_local" fw_is_write_pulse="true" fw_write_pulse_length="1"/>
            <node id="MMCM_RESET" address="0x0" mask="0x40000000" permission="w" description="TTC MMCM reset"
                  fw_signal="ttc_ctrl.mmcm_reset" fw_is_write_pulse="true" fw_write_pulse_length="3"/>
            <node id="CNT_RESET" address="0x0" mask="0x20000000" permission="w" description="TTC counter reset"
                  fw_signal="ttc_ctrl.cnt_reset" fw_is_write_pulse="true" fw_write_pulse_length="1"
                  sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
            <node id="MMCM_PHASE_SHIFT" address="0x0" mask="0x10000000" permission="w" description="TTC MMCM phase shift trigger"
                  fw_signal="ttc_ctrl.mmcm_phase_shift" fw_is_write_pulse="true" fw_write_pulse_length="1"/>
            <node id="L1A_ENABLE" address="0x0" mask="0x00000001" permission="rw" description="Enable L1As (L1As are blocked if this is 0)"
                  fw_signal="ttc_ctrl.l1a_enable" fw_default="0b1"
                  sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x1" sw_ctrl_stop_set="0x0"/>
        </node>
        <node id="CONFIG" address="0x1" description="TTC configuration -- used for setup TTC command decoding">
            <node id="CMD_BC0" address="0x0" mask="0x000000ff" permission="rw" description="BC0 command code"
                  fw_signal="ttc_conf.cmd_bc0" fw_default="0x01"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_EC0" address="0x0" mask="0x0000ff00" permission="rw" description="EC0 command code"
                  fw_signal="ttc_conf.cmd_ec0" fw_default="0x02"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_RESYNC" address="0x0" mask="0x00ff0000" permission="rw" description="Resync command code"
                  fw_signal="ttc_conf.cmd_resync" fw_default="0x04"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_OC0" address="0x0" mask="0xff000000" permission="rw" description="OC0 command code"
                  fw_signal="ttc_conf.cmd_oc0" fw_default="0x08"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_HARD_RESET" address="0x1" mask="0x000000ff" permission="rw" description="Hard-reset command code"
                  fw_signal="ttc_conf.cmd_hard_reset" fw_default="0x10"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_CALPULSE" address="0x1" mask="0x0000ff00" permission="rw" description="Calibration pulse command code"
                  fw_signal="ttc_conf.cmd_calpulse" fw_default="0x14"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_START" address="0x1" mask="0x00ff0000" permission="rw" description="START command code"
                  fw_signal="ttc_conf.cmd_start" fw_default="0x18"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_STOP" address="0x1" mask="0xff000000" permission="rw" description="STOP command code"
                  fw_signal="ttc_conf.cmd_stop" fw_default="0x1c"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_TEST_SYNC" address="0x2" mask="0x000000ff" permission="rw" description="Test-sync command code"
                  fw_signal="ttc_conf.cmd_test_sync" fw_default="0x20"
                  sw_ctrl_configure_confdb_check_set="true"/>
        </node>
        <node id="STATUS" address="0x4" description="TTC status">
            <node id="MMCM_LOCKED" address="0x0" mask="0x00000001" permission="r" description="MMCM locked flag"
                  fw_signal="ttc_status.mmcm_locked"
                  sw_monitor_error_value="0"/>
            <node id="TTC_SINGLE_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r" description="TTC stream single bit error count"
                  fw_signal="ttc_status.single_err"
                  sw_monitor_warn_min_threshold="1"/>
            <node id="TTC_DOUBLE_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r" description="TTC stream double bit error count"
                  fw_signal="ttc_status.double_err"
                  sw_monitor_error_min_threshold="1"/>
            <node id="BC0" address="0x2" description="TTC status">
                <node id="LOCKED" address="0x0" mask="0x00000001" permission="r" description="BC0 locked flag"
                      fw_signal="ttc_status.bc0_status.locked"
                      sw_monitor_error_value="0"/>
                <node id="UNLOCK_CNT" address="0x1" mask="0x0000ffff" permission="r" description="BC0 unlock count"
                      fw_signal="ttc_status.bc0_status.unlocked_cnt"
                      sw_monitor_error_min_threshold="1"/>
                <node id="OVERFLOW_CNT" address="0x2" mask="0x0000ffff" permission="r" description="BX counter overflow count (late or no BC0 received)"
                      fw_signal="ttc_status.bc0_status.ovf_cnt"
                      sw_monitor_error_min_threshold="1"/>
                <node id="UNDERFLOW_CNT" address="0x2" mask="0xffff0000" permission="r" description="BX counter underflow count (early BC0 received, one is normal after the TTC module reset, but this should be reset by control software before each run)"
                      fw_signal="ttc_status.bc0_status.udf_cnt"
                      sw_monitor_error_min_threshold="1"/>
            </node>
        </node>

        <node id="CMD_COUNTERS" address="0x9" description="TTC command counters">
            <node id="L1A" address="0x0" mask="0xffffffff" permission="r" description="L1A count"
                  fw_signal="ttc_cmds_cnt_arr(0)"/>
            <node id="BC0" address="0x1" mask="0xffffffff" permission="r" description="BC0 count"
                  fw_signal="ttc_cmds_cnt_arr(1)"/>
            <node id="EC0" address="0x2" mask="0xffffffff" permission="r" description="EC0 count"
                  fw_signal="ttc_cmds_cnt_arr(2)"/>
            <node id="RESYNC" address="0x3" mask="0xffffffff" permission="r" description="Resync count"
                  fw_signal="ttc_cmds_cnt_arr(3)"/>
            <node id="OC0" address="0x4" mask="0xffffffff" permission="r" description="OC0 count"
                  fw_signal="ttc_cmds_cnt_arr(4)"/>
            <node id="HARD_RESET" address="0x5" mask="0xffffffff" permission="r" description="Hard-reset count"
                  fw_signal="ttc_cmds_cnt_arr(5)"/>
            <node id="CALPULSE" address="0x6" mask="0xffffffff" permission="r" description="Calibration pulse count"
                  fw_signal="ttc_cmds_cnt_arr(6)"/>
            <node id="START" address="0x7" mask="0xffffffff" permission="r" description="START count"
                  fw_signal="ttc_cmds_cnt_arr(7)"/>
            <node id="STOP" address="0x8" mask="0xffffffff" permission="r" description="STOP count"
                  fw_signal="ttc_cmds_cnt_arr(8)"/>
            <node id="TEST_SYNC" address="0x9" mask="0xffffffff" permission="r" description="Test-sync count"
                  fw_signal="ttc_cmds_cnt_arr(9)"/>
        </node>

        <node id="L1A_ID" address="0x13" mask="0x00ffffff" permission="r" description="L1A ID (increments with every L1A and resets with EC0), used by DAQ to tag event numbers"
              fw_signal="l1id_cnt"/>

        <node id="TTC_SPY_BUFFER" address="0x14" mask="0xffffffff" permission="r" description="TTC Spy buffer -- this is filled with TTC commands (from LSB to MSB) and freezes until the user reads it out, once read out it resets and fills up again with new TTC commands received from that point on"
              fw_signal="ttc_spy_buffer" fw_read_pulse_signal="ttc_spy_reset" fw_read_pulse_length="1"/>
    </node>
    <!--end TTC module -->

    <!--Trigger module -->
    <node id="TRIGGER"  address="0x00800000"
          description="Trigger module handles everything related to sbit cluster data (link synchronization, monitoring, local triggering, matching to L1A and reporting data to DAQ)"
          fw_is_module="true"
          fw_module_file="../common/hdl/trigger/trigger.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

        <node id="CTRL" address="0x0" description="Trigger control">
            <node id="MODULE_RESET" address="0x0" mask="0x80000000" permission="w"
                  description="Trigger module reset"
                  fw_signal="reset_local" fw_is_write_pulse="true" fw_write_pulse_length="1"/>
            <node id="CNT_RESET" address="0x0" mask="0x40000000" permission="w"
                  description="Trigger counter reset"
                  fw_signal="reset_cnt" fw_is_write_pulse="true" fw_write_pulse_length="1"
                  sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
            <node id="OH_KILL_MASK" address="0x1" mask="0x00ffffff" permission="rw"
                  description="OH trigger kill mask (kills all sbits from the corresponding OHs)"
                  fw_signal="oh_mask"
                  fw_default="0x000000"/>
        </node>

        <node id="STATUS" address="0x10" description="Trigger status">
            <node id="OR_TRIGGER_RATE" address="0x0" mask="0xffffffff" permission="r"
                  description="OR-Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster on any link"
                  fw_signal="or_trigger_rate"
                  sw_monitor_warn_min_threshold="1000000"/>
        </node>

        <node id="OH${OH_IDX}" address="0x100" description="Trigger link for OH ${OH_IDX}"
              generate="true" generate_size="4" generate_address_step="0x100" generate_idx_var="OH_IDX">
            <node id="TRIGGER_RATE" address="0x0" mask="0xffffffff" permission="r"
                  description="Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster"
                  fw_signal="trigger_rate(${OH_IDX})"
                  sw_monitor_warn_min_threshold="1000000"/>
            <node id="CLUSTER_SIZE_${CS_IDX}_RATE" address="0x1" mask="0xffffffff" permission="r"
                  description="Rate of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
                  fw_signal="cluster_cnt_rate(${OH_IDX} * 9 + ${CS_IDX})"
                  generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
            <node id="LINK0_NOT_VALID_CNT" address="0xa" mask="0x0000ffff" permission="r"
                  description="Count of valid flag being 0 in the sync FIFO for link 0"
                  fw_signal="not_valid_cnt(${OH_IDX})(15 downto 0)"
                  sw_monitor_error_min_threshold="100"/>
            <node id="LINK1_NOT_VALID_CNT" address="0xa" mask="0xffff0000" permission="r"
                  description="Count of valid flag being 0 in the sync FIFO for link 1"
                  fw_signal="not_valid_cnt(${OH_IDX})(31 downto 16)"
                  sw_monitor_error_min_threshold="100"/>
            <node id="LINK0_MISSED_COMMA_CNT" address="0xb" mask="0x0000ffff" permission="r"
                  description="Count of missed comma character at the expected time for link 0 (this indicates an out-of-sync condition)"
                  fw_signal="missed_comma_cnt(${OH_IDX})(15 downto 0)"
                  sw_monitor_error_min_threshold="1"/>
            <node id="LINK1_MISSED_COMMA_CNT" address="0xb" mask="0xffff0000" permission="r"
                  description="Count of missed comma character at the expected time for link 1 (this indicates an out-of-sync condition)"
                  fw_signal="missed_comma_cnt(${OH_IDX})(31 downto 16)"
                  sw_monitor_error_min_threshold="1"/>
            <node id="LINK0_OVERFLOW_CNT" address="0xc" mask="0x0000ffff" permission="r"
                  description="Count of overflow occurances in the sync FIFO for link 0"
                  fw_signal="link_overflow_cnt(${OH_IDX})(15 downto 0)"
                  sw_monitor_error_min_threshold="1"/>
            <node id="LINK1_OVERFLOW_CNT" address="0xc" mask="0xffff0000" permission="r"
                  description="Count of overflow occurances in the sync FIFO for link 1"
                  fw_signal="link_overflow_cnt(${OH_IDX})(31 downto 16)"
                  sw_monitor_error_min_threshold="1"/>
            <node id="LINK0_UNDERFLOW_CNT" address="0xd" mask="0x0000ffff" permission="r"
                  description="Count of underflow occurances in the sync FIFO for link 0"
                  fw_signal="link_underflow_cnt(${OH_IDX})(15 downto 0)"
                  sw_monitor_error_min_threshold="1"/>
            <node id="LINK1_UNDERFLOW_CNT" address="0xd" mask="0xffff0000" permission="r"
                  description="Count of underflow occurances in the sync FIFO for link 1"
                  fw_signal="link_underflow_cnt(${OH_IDX})(31 downto 16)"
                  sw_monitor_error_min_threshold="1"/>
            <node id="LINK0_SYNC_WORD_CNT" address="0xe" mask="0x0000ffff" permission="r"
                  description="Count of sync words seen on link 0"
                  fw_signal="sync_word_cnt(${OH_IDX})(15 downto 0)"/>
            <node id="LINK1_SYNC_WORD_CNT" address="0xe" mask="0xffff0000" permission="r"
                  description="Count of sync words seen on link 1"
                  fw_signal="sync_word_cnt(${OH_IDX})(31 downto 16)"/>
            <node id="DEBUG_LAST_CLUSTER_${CLUSTER_IDX}" address="0x10" mask="0x0000ffff" permission="r"
                  description="Last cluster ${CLUSTER_IDX}"
                  fw_signal="'0' &amp; sbit_clusters_i(${OH_IDX})(${CLUSTER_IDX}).size &amp; '0' &amp; sbit_clusters_i(${OH_IDX})(${CLUSTER_IDX}).address"
                  generate="true" generate_size="8" generate_address_step="0x1" generate_idx_var="CLUSTER_IDX"/>
        </node>

    </node>
    <!--end trigger module -->

    <!--GEM System module -->
    <node id="GEM_SYSTEM"  address="0x00900000"
          description="This module is controlling GEM AMC System wide settings"
          fw_is_module="true"
          fw_module_file="../common/hdl/misc/gem_system_regs.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="3"
          fw_reg_addr_lsb="0">
          
        <node id="TK_LINK_RX_POLARITY" address="0x0" mask="0x00ffffff" permission="rw"
              description="RX polarity of the track/control links (bit 0 corresponds to link 0)"
              fw_signal="tk_rx_polarity" fw_default="0x000000"/>
        <node id="TK_LINK_TX_POLARITY" address="0x1" mask="0x00ffffff" permission="rw"
              description="TX polarity of the track/control links (bit 0 corresponds to link 0)"
              fw_signal="tk_tx_polarity" fw_default="0x000000"/>
        <node id="BOARD_ID" address="0x2" mask="0x0000ffff" permission="rw"
              description="Board ID that gets embedded in the AMC13 header"
              fw_signal="board_id" fw_default="0xbeef"/>
        <node id="RELEASE_MAJOR" address="0x3" mask="0x00ff0000" permission="r"
              description="Firmware release major version"
              fw_signal="std_logic_vector(to_unsigned(version_major, 8))"/>
        <node id="RELEASE_MINOR" address="0x3" mask="0x0000ff00" permission="r"
              description="Firmware release minor version"
              fw_signal="std_logic_vector(to_unsigned(version_minor, 8))"/>
        <node id="RELEASE_BUILD" address="0x3" mask="0x000000ff" permission="r"
              description="Firmware release build version"
              fw_signal="std_logic_vector(to_unsigned(version_build, 8))"/>
        <node id="RELEASE_YEAR" address="0x4" mask="0xfff00000" permission="r"
              description="Firmware release year"
              fw_signal="std_logic_vector(to_unsigned(date_year, 12))"/>
        <node id="RELEASE_MONTH" address="0x4" mask="0x00000f00" permission="r"
              description="Firmware release month"
              fw_signal="std_logic_vector(to_unsigned(date_month, 4))"/>
        <node id="RELEASE_DAY" address="0x4" mask="0x000000ff" permission="r"
              description="Firmware release day"
              fw_signal="std_logic_vector(to_unsigned(date_day, 8))"/>
    </node>

    <!--DAQ module -->
    <node id="DAQ"  address="0x00700000"
          description="DAQ module buffers track data, builds events, analyses the data for consistency and ships off the events with all the needed headers and trailers to AMC13 over DAQLink"
          fw_is_module="true"
          fw_module_file="../common/hdl/daq/daq.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="8"
          fw_reg_addr_lsb="0">
          
        <node id="CONTROL"  address="0x0" description="DAQ Control">
            <node id="DAQ_ENABLE"         address="0x0" mask="0x00000001" permission="rw"
                  description="If this is set to 0, there will be no data sent to AMC13 and TTS state will always be READY (0x8)"
                  fw_signal="daq_enable" fw_default="0b0"/>
            <node id="DAQ_LINK_RESET"     address="0x0" mask="0x00000004" permission="rw"
                  description="Directly connected to DAQLink module reset port. BU is
                               advising against ever using it except for powerup, but it
                               may clear some error conditions (like daqlink_almost_ful
                               stuck at 1). AMC13 reset is probably required after this."
                  fw_signal="reset_daqlink_ipb" fw_default="0b0"/>
            <node id="RESET"              address="0x0" mask="0x00000008" permission="rw"
                  description="Clears all FIFOs, state flags and counters. It also stops and
                               resets all state machines (no events will be built, recorded
                               or sent during reset)
                               When set to 1, it will be held in reset state until 0 is
                               explicitly written (this can be changed in the future if
                               necessary)"
                  fw_signal="reset_local" fw_default="0b0"/>
            <node id="TTS_OVERRIDE"       address="0x0" mask="0x000000f0" permission="rw"
                  description="When not 0, it will override the GLIB TTS state with the
                               provided value (e.g. writing 0x8 will force GLIB to always be
                               in TTS READY state)"
                  fw_signal="tts_override" fw_default="0x0"/>
            <node id="INPUT_ENABLE_MASK"  address="0x0" mask="0xffffff00" permission="rw"
                  description="This is a bitmask telling GLIB to enable certain inputs (least
                               significant bit is input 0). Only first is enabled by default"
                  fw_signal="input_mask" fw_default="0x1"/>
            <node id="DAV_TIMEOUT"        address="0x6"  mask="0x00ffffff" permission="rw"
                  description="This setting controls how long DAQ will wait for individual
                               inputs to report data before calling it timed-out  (if timeout
                               occurs a header and trailer for that chamber will still be
                               inserted and timeout flag will be set there, though no VFAT
                               payload will be present). Units = clock cycles @ 25MHz
                               (current DAQLink clk frequency)"
                  fw_signal="dav_timeout" fw_default="0x3d090"/>
        </node>
        
        <node id="STATUS"  address="0x1" description="DAQ global status registers">
            <node id="DAQ_LINK_RDY"    address="0x0"  mask="0x00000001" permission="r"
                  description="When this is 1, it means that GLIB is in good communication
                               with AMC13. It must be 1 for GLIB to be able to send data."
                  fw_signal="daq_ready"/>
            <node id="DAQ_CLK_LOCKED"  address="0x0"  mask="0x00000002" permission="r"
                  description="This flag is 1 if DAQ clock is locked at this moment"
                  fw_signal="daq_clk_locked_i"/>
            <node id="TTC_RDY"         address="0x0"  mask="0x00000004" permission="r"
                  description="This flag is 1 if TTC clock MMCM is locked"
                  fw_signal="ttc_status_i.mmcm_locked"/>
            <node id="DAQ_LINK_AFULL"       address="0x0"  mask="0x00000008" permission="r"
                  description="This bit comes directly from DAQLink module, indicating
                               that its internal buffers are almost full. No events will be sent
                               when this bit is 1 (though events can still be built and
                               stored in the Input and Event FIFOs)"
                  fw_signal="daq_almost_full"/>
            <node id="TTC_BC0_LOCKED"       address="0x0"  mask="0x00000010" permission="r"
                  description="This bit is set if BC0 is currently locked (last BC0 arrived at the expected time)"
                  fw_signal="ttc_status_i.bc0_status.locked"/>
            <node id="L1A_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00800000" permission="r"
                  description="This bit is latched whenever L1A FIFO overflow is asserted.
                               This means that one or more L1As were lost, so we are
                               out-of-sync: resync or reset is needed"
                  fw_signal="err_l1afifo_full"/>
            <node id="L1A_FIFO_IS_UNDERFLOW"       address="0x0"  mask="0x01000000" permission="r"
                  description="L1A FIFO is in underflow at this moment (this bit is not latched)"
                  fw_signal="l1afifo_underflow"/>
            <node id="L1A_FIFO_IS_FULL"       address="0x0"  mask="0x02000000" permission="r"
                  description="L1A FIFO is full at this moment (this bit is not latched)"
                  fw_signal="l1afifo_full"/>
            <node id="L1A_FIFO_IS_NEAR_FULL"       address="0x0"  mask="0x04000000" permission="r"
                  description="This bit gets asserted when L1A FIFO gets 75% full and deasserted when it gets down to 50%"
                  fw_signal="l1afifo_near_full"/>
            <node id="L1A_FIFO_IS_EMPTY"       address="0x0"  mask="0x08000000" permission="r"
                  description="L1A FIFO is empty at this moment (this bit is not latched)"
                  fw_signal="l1afifo_empty"/>
            <node id="TTS_STATE"       address="0x0"  mask="0xf0000000" permission="r"
                  description="Current TTS state (READY, BUSY, ERROR, WARN, OUT-OF-SYNC)"
                  fw_signal="tts_state"/>
        </node>
        
        <node id="EXT_STATUS"  address="0x2" description="DAQ global extended status registers">
            <node id="NOTINTABLE_ERR"  address="0x0"  mask="0x0000ffff" permission="r"
                  description="This counter is counting DAQLink GTX/GTH not-in-table errors"
                  fw_signal="daq_notintable_err_cnt"/>
            <node id="DISPER_ERR"      address="0x1"  mask="0x0000ffff" permission="r"
                  description="This counter is counting DAQLink GTX/GTH dispersion errors"
                  fw_signal="daq_disper_err_cnt"/>
            <node id="L1AID"           address="0x2"  mask="0x00ffffff" permission="r"
                  description="Current L1A ID (similar to event number, but this may be a bit ahead of that if we're still waiting for data for unprocessed L1As)"
                  fw_signal="ttc_daq_cntrs_i.l1id"/>
            <node id="EVT_SENT"        address="0x3"  mask="0xffffffff" permission="r"
                  description="Number of events shipped out to DAQLink"
                  fw_signal="std_logic_vector(cnt_sent_events)"/>
            <node id="MAX_DAV_TIMER"   address="0x5"  mask="0x00ffffff" permission="r"
                  description="This indicates the maximum amount of time that DAQ had
                               to wait for all inputs to report data (can be used to optimize
                               DAV timeout setting). Units = clock cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)
                               (current DAQLink clk frequency)"
                  fw_signal="std_logic_vector(max_dav_timer)"/>
            <node id="LAST_DAV_TIMER"  address="0x6"  mask="0x00ffffff" permission="r"
                  description="This indicates how DAQ had to wait for all inputs to report
                               data for the last event (mostly for debugging). Units = clock
                               cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)"
                  fw_signal="std_logic_vector(last_dav_timer)"/>
        </node>

        <node id="EXT_CONTROL"  address="0xe" description="DAQ global extended configuration registers">
            <node id="RUN_TYPE"       address="0x1"  mask="0x0f000000" permission="rw"
                  description="User settable run type that gets embedded into the AMC header"
                  fw_signal="run_type" fw_default="0x0"/>
            <node id="RUN_PARAMS"     address="0x1"  mask="0x00ffffff" permission="rw"
                  description="User settable run params that gets embedded into the AMC header"
                  fw_signal="run_params" fw_default="0x000000"/>
        </node>

        <node id="OH${OH_IDX}"  address="0x10"
              description="Link specific registers for OH${OH_IDX}"
              generate="true" generate_size="4" generate_address_step="0x10" generate_idx_var="OH_IDX">
            
            <node id="CONTROL"  address="0x0">
                <node id="EOE_TIMEOUT" address="0x3"  mask="0x00ffffff" permission="rw"
                      description="Units = clock cycles @ 160MHz. 
                                   If no new data was received in this amount of time, GLIB
                                   will close the current event and report it to DAQ. This is one
                                   of the two ways to close an event, the other is to get new
                                   data with different BX number"
                      fw_signal="input_control_arr(${OH_IDX}).eb_timeout_delay" fw_default="0x0030d4"/>
            </node>

            <node id="STATUS"  address="0x0">
                <node id="VFAT_MIXED_EC"    mask="0x00000002" permission="r"
                      description="There was at least one event with mixed VFAT Event IDs"
                      fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_ec"/>
                <node id="VFAT_MIXED_BC"  mask="0x00000004" permission="r"
                      description="There was at least one event with mixed VFAT BX IDs"
                      fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_bc"/>
                <node id="OH_MIXED_BC"         mask="0x00000008" permission="r"
                      description="There was at least one event with mixed OH BX IDs (OH BX
                                   ID is reported for every VFAT block, but not sent to
                                   AMC13)."
                      fw_signal="input_status_arr(${OH_IDX}).err_mixed_oh_bc"/>

                <node id="VFAT_TOO_MANY"      mask="0x00000010" permission="r"
                      description="Corruption: more than 24 VFATs in event"
                      fw_signal="input_status_arr(${OH_IDX}).err_event_bigger_than_24"/>
                <node id="VFAT_SMALL_BLOCK"   mask="0x00000020" permission="r"
                      description="Corruption: VFAT block smaller than 192bits"
                      fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_small"/>
                <node id="VFAT_LARGE_BLOCK"   mask="0x00000040" permission="r"
                      description="Corruption: VFAT block bigger than 192bits"
                      fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_big"/>
                <node id="VFAT_NO_MARKER"     mask="0x00000080" permission="r"
                      description="Corruption: VFAT marker not detected.
                                   There was at least one VFAT block not conforming to the
                                   pattern of Axxx Cxxx Exxx... (see VFAT data format)
                                   Note that this data will still be included in the current event
                                   and sent to AMC13, but it will not be considered in
                                   end­of­event detection"
                      fw_signal="input_status_arr(${OH_IDX}).err_corrupted_vfat_data"/>
                <node id="INPUT_FIFO_HAD_OFLOW"   mask="0x00000100" permission="r"
                      description="Critical: Input FIFO overflow occurred.
                                   This bit is latched if Input FIFO was ever full when receiving
                                   new data – this means data was lost.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${OH_IDX}).err_infifo_full"/>
                <node id="INPUT_FIFO_HAD_UFLOW"   mask="0x00000200" permission="r"
                      description="Critical: Input FIFO underflow occurred.
                                   This bit is latched if Input FIFO underflow was ever
                                   detected. This means that Event FIFO indicated that there
                                   should be more data than was stored in Input FIFO. This
                                   might happen due to overflow or some other malfunction.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${OH_IDX}).err_infifo_underflow"/>
                <node id="EVENT_FIFO_HAD_OFLOW"   mask="0x00000400" permission="r"
                      description="Critical: Event FIFO overflow occurred.
                                   This bit is latched if Event FIFO was ever full when trying to
                                   build a new event. This means data was lost.
                                   It’s not likely that this will ever be asserted because Input
                                   FIFO should overflow first.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${OH_IDX}).err_evtfifo_full"/>
                <node id="EVT_SIZE_ERR"           mask="0x00000800" permission="r"
                      description="Critical: Event size overflow occurred.
                                   This bit is latched if there was an event containing more
                                   than 4096 VFAT blocks. Input FIFO and Event FIFO will be
                                   out­of­sync. This might happen if end­of­event is not
                                   detected properly or for whatever reason GLIB is receiving
                                   a stream of VFAT blocks indicating that they belong to the
                                   same event (EC/BC is the same)
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${OH_IDX}).err_event_too_big"/>
                <node id="TTS_STATE"           mask="0x0000f000" permission="r"
                      description="Input TTS state (gets integrated into global TTS state later)"
                      fw_signal="input_status_arr(${OH_IDX}).tts_state"/>
                <node id="INPUT_FIFO_IS_UFLOW"    mask="0x01000000" permission="r"
                      description="Current status: Input FIFO is in underflow"
                      fw_signal="input_status_arr(${OH_IDX}).infifo_underflow"/>
                <node id="INPUT_FIFO_IS_FULL"     mask="0x02000000" permission="r"
                      description="Current status: Input FIFO is full"
                      fw_signal="input_status_arr(${OH_IDX}).infifo_full"/>
                <node id="INPUT_FIFO_IS_AFULL"    mask="0x04000000" permission="r"
                      description="Current status: Input FIFO is near­full (asserted at 75% and deasserted at 50%)"
                      fw_signal="input_status_arr(${OH_IDX}).infifo_near_full"/>
                <node id="INPUT_FIFO_IS_EMPTY"    mask="0x08000000" permission="r"
                      description="Current status: Input FIFO is empty"
                      fw_signal="input_status_arr(${OH_IDX}).infifo_empty"/>
                <node id="EVENT_FIFO_IS_UFLOW"    mask="0x10000000" permission="r"
                      description="Current status: Event FIFO is in underflow"
                      fw_signal="input_status_arr(${OH_IDX}).evtfifo_underflow"/>
                <node id="EVENT_FIFO_IS_FULL"     mask="0x20000000" permission="r"
                      description="Current status: Event FIFO is full"
                      fw_signal="input_status_arr(${OH_IDX}).evtfifo_full"/>
                <node id="EVENT_FIFO_IS_AFULL"    mask="0x40000000" permission="r"
                      description="Current status: Event FIFO is near­full (asserted at 75% and deasserted at 50%)"
                      fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full"/>
                <node id="EVENT_FIFO_IS_EMPTY"    mask="0x80000000" permission="r"
                      description="Current status: Event FIFO is empty"
                      fw_signal="input_status_arr(${OH_IDX}).evtfifo_empty"/>
            </node>

            <node id="COUNTERS">
                <node id="CORRUPT_VFAT_BLK_CNT"  address="0x1" mask="0xffffffff" permission="r"
                      description="This counter is incremented when a VFAT block does not
                                   conform to the pattern of Axxx Cxxx Exxx... (see VFAT
                                   data format)
                                   Note that this data is still included in events and sent to
                                   AMC13, but it does not participate in end-of-event
                                   detection."
                      fw_signal="input_status_arr(${OH_IDX}).cnt_corrupted_vfat"/>
                <node id="EVN"                   address="0x2" mask="0x00ffffff" permission="r"
                      description="Current event number of the event builder.
                                   This counter starts at 1 and increments with each
                                   end-of-event detection. This number should be similar to
                                   the number of events sent to AMC13 in normal operation,
                                   but it might not always be exactly the same because there's
                                   some latency between building an event and sending it. In
                                   addition, event sending could stop due to DAQ FIFO being
                                   almost full or DAQLink not being ready."
                      fw_signal="input_status_arr(${OH_IDX}).eb_event_num"/>
                <node id="MAX_EOE_TIMER"         address="0x7" mask="0x00ffffff" permission="r"
                      description="Units = clock cycles @ 160MHz. 
                                   This indicates the maximum amount of time that event
                                   builder took to build and close the event. Note: this is
                                   mostly for debugging, most of the time it should be equal
                                   to 'End of event timeout'"
                      fw_signal="input_status_arr(${OH_IDX}).eb_max_timer"/>
                <node id="LAST_EOE_TIMER"        address="0x8" mask="0x00ffffff" permission="r"
                      description="Units = clock cycles @ 160MHz. 
                                   This shows how long event builder took to build and close
                                   the last event. Note: this is mostly for debugging, but could
                                   be used to tune the 'end of event timeout'"
                      fw_signal="input_status_arr(${OH_IDX}).eb_last_timer"/>
            </node>

            <node id="LASTBLOCK${BLOCK_IDX}"  address="0x9" permission="r" mask="0xffffffff"
                  description="contains the last 192+32 bits received from the VFAT and OH"
                  generate="true" generate_size="7" generate_address_step="0x1" generate_idx_var="BLOCK_IDX"
                  fw_signal="input_status_arr(${OH_IDX}).ep_vfat_block_data(${BLOCK_IDX})">
            </node>
        </node>
    </node>
    
    <!--OptoHybrid module -->
    <node id="OptoHybrid"  address="0x00400000"
          description="Optohybrid Registers"
          fw_is_module="true"
          fw_is_module_external="true">
                    
        <node id="OH${OH_IDX}"  address="0x0" description="Optohybrid ${OH_IDX}"
              generate="true" generate_size="4" generate_address_step="0x00010000" generate_idx_var="OH_IDX">

            <node id="COUNTERS"  address="0xa000000"
                    description="Counters provided on the OptoHybrid">       

                <node id="T1"  address="0x54"
                        description="Counters related to the OptoHybrid T1 signals">
                    <node id="TTC"       address="0x00"
                            description="T1 signals received from the GLIB TTC decoder
                                        by way of the uTCA backplane (AMC13)">
                        <node id="L1A"      address="0x0"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="CalPulse" address="0x1"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="Resync"   address="0x2"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="BC0"      address="0x3"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>                                        
                    </node>
                    
                    <node id="INTERNAL"  address="0x04"
                            description="T1 signals generated by the OptoHybrid firmware">

                        <node id="L1A"      address="0x0"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="CalPulse" address="0x1"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="Resync"   address="0x2"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="BC0"      address="0x3"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>                                        

                    </node>

                    <node id="EXTERNAL"  address="0x08"
                            description="T1 signals recieved from an external source">

                        <node id="L1A"      address="0x0"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="CalPulse" address="0x1"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="Resync"   address="0x2"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="BC0"      address="0x3"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>                                        

                    </node>
                    <node id="LOOPBACK"  address="0x0c"
                            description="T1 signals sent in loopback mode">

                        <node id="L1A"      address="0x0"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="CalPulse" address="0x1"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="Resync"   address="0x2"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="BC0"      address="0x3"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>                                        

                    </node>
                    <node id="SENT"      address="0x10"
                            description="T1 signals sent to the GEB (VFATs)">

                        <node id="L1A"      address="0x0"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="CalPulse" address="0x1"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="Resync"   address="0x2"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>
                        <node id="BC0"      address="0x3"  permission="r">
                            <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                        </node>                                        

                    </node>
                </node>

                <node id="GTX"  address="0x68"
                        description="Counters related to the OptoHybrid optical links">

                    <node id="TRK_ERR"   address="0x0"  permission="r"
                            description="Error counter on the tracking data optical link">
                        <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                    </node>

                    <node id="TRG_ERR"   address="0x2"  permission="r"
                            description="Error counter on the trigger data optical link">
                        <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                    </node>

                    <node id="DATA_Packets"   address="0x4"  permission="r"
                            description="Number of received data packets counter on the optical link">
                        <node id="Reset"  address="0x0"  mask="0x1"  permission="w"/>
                    </node>
                    
                </node>                    
            </node> <!-- end of COUNTERS -->


            <node id="CONTROL"  address="0xb000000"
                description="Control registers of the OptoHybrid">

                  <node id="VFAT"  address="0x0"  permission="rw"
                    description="Control on the OptoHybrid related to the VFATs">
                    <node id="MASK"  address="0x0"  mask="0xffffffff"  permission="rw"
                          description="Masks individual VFATs from sending tracking data packets"/>
                    <node id="RESET"  address="0x3"  mask="0x1"  permission="w"
                          description="Returns to a 0 state"/>
                  </node>
                  <node id="TRIGGER" address="0x1" permission="rw"
                        description="Trigger options for the OptoHybrid">
                    <node id="SOURCE"  address="0x0"  mask="0x7"  permission="rw"
                          description="Selects the source of T1 signals sent to the GEB (3 bits [0,4]:
                                       0: T1 from GLIB TTC decoder over backplane (AMC13)
                                       1: T1 from OptoHybrid firmware
                                       2: T1 from external source
                                       3: Internal loopback on S-bits
                                       4: Logical OR of all sources"/>
                    <node id="LOOPBACK"  address="0x1"  mask="0x1f"  permission="rw"
                          description="Selects the S-bit source to loop back  (5 bits)"/>
                  </node>

                  <node id="CLOCK"  address="0x4"  permission="rw"
                    description="Control on the OptoHybrid related to the clocking">
                    <node id="REF_CLK"  address="0x0"  mask="0x3"  permission="rw"
                          description="Select the reference clock source (3 bits):
                                       0: on board oscillator
                                       1: GTX recovered clock
                                       2: external clock"/>
                  </node>
                  
                  <node id="OUTPUT"  address="0x5"  permission="rw"
                    description="Control on the OptoHybrid related to the SBits sent out">
                    <node id="SBits"  address="0x0"  permission="rw"
                          description="Select the SBit sources to send out (30 bits, maximum 6 may be set high)"/>
                  </node>
            </node> <!-- end of CONTROL -->
    
            <node id="STATUS"  address="0xc000000"
                    description="Status registers of the OptoHybrid">

                <node id="FW"  address="0x0"  permission="r"
                        description="Firmware version on the OH"/>

                <node id="FPGA_PLL_LOCK"  address="0x1"  mask="0x1"  permission="r"
                    description="Returns the lock status of the FPGA clock PLL"/>
                <node id="EXT_PLL_LOCK"   address="0x2"  mask="0x1"  permission="r"
                    description="Returns the lock status of the external clock PLL"/>
                <node id="CDCE_LOCK"      address="0x3"  mask="0x1"  permission="r"
                    description="Returns the lock status of the CDCE"/>
                <node id="GTX_LOCK"       address="0x4"  mask="0x1"  permission="r"
                    description="Returns the lock status of the recovered clock (GTX)"/>                    
            </node>

            <node id="FW_DATE" address="0xc000" mask="0xffffffff" permission="r"
                  description="OH firmware date"/>        
        </node> <!-- end OH${OH_IDX} block -->
    </node> <!-- end OptoHybrid block -->
  </node>
</node>
